### #1476 날짜 계산

```python
# 브루트 포스
# ref: https://jitolit.tistory.com/123
def solution(e, s, m):
    year = 1
    i, j, k = 1, 1, 1
    while True:
        if i == e and j == s and k == m:
            break
        i += 1
        j += 1
        k += 1
        year += 1
        if i == 16:
            i = 1
        if j == 29:
            j = 1
        if k == 20:
            k = 1
    return year


if __name__ == '__main__':
    e, s, m = map(int, input().split())
    print(solution(e, s, m))

```

[참고](https://jitolit.tistory.com/123)

- e, s, m이 1, 1, 1일 때부터 차례대로 탐색한다 (15 * 28 * 19 = 최대 7980개 조합이므로 가능)
- 각 숫자의 범위를 초과할 경우 다시 1로 초기화



### #1107 리모컨

```python
# 런타임 에러(ValueError)
def solution(n, buttons):
    count = 0
    nums = set(range(10))
    channel = 0
    default = 100

    if n == default:
        return 0
    if buttons:
        nums = nums - set(buttons)
    nums = list(nums)

    # 100에서 출발한다는 점을 완전히 반영하지 못함
    for num in str(n):
        if int(num) in nums:
            count += 1
            channel = channel*10 + int(num)
        else:
            diff = [abs(int(num)-x) for x in nums]
            count += 1
            channel = channel*10 + nums[diff.index(min(diff))]
    count += abs(n - channel)

    return min(n-default, count)


if __name__ == '__main__':
    n = int(input())
    m = int(input())
    buttons = list(map(int, input().split())) if m != 0 else []
    print(solution(n, buttons))
```

```python
# ref: https://jjangsungwon.tistory.com/30
if __name__ == "__main__":

    enable = {str(i) for i in range(10)}  # 0, 1, 2 ... 9 (가능한 수)

    # input
    N = int(input())  # 이동하려고 하는 채널
    M = int(input())  # 고장난 버튼의 개수
    if M != 0:
        enable -= set(map(str, input().split()))  # 고장난 버튼 리스트 제거

    # case1 (100번에서 +, - 로만 움직이는 경우)
    min_cnt = abs(100 - N)

    # case2 (1,000,000 채널까지 브루트 포스 진행)
    # 500,000 채널까지 존재하기 때문에 500,000 보다 크면서 모든 숫자의 경우를 거치는 1,000,000까지를 범위로 잡음
    for num in range(1000001):
        num = str(num)
        for j in range(len(num)):
            if num[j] not in enable:
                break
            elif j == len(num) - 1:
                min_cnt = min(min_cnt, abs(N - int(num)) + len(str(num)))
    print(min_cnt)
```

[참고](https://jjangsungwon.tistory.com/30)

- 브루트 포스로 모든 범위의 채널(1000000)을 고려해야 한다.



### #1451 직사각형으로 나누기

```python
n, m = map(int, input().split())

# 입력받은 전체 직사각형을 저장하기 위한 리스트(편리한 인덱싱을 위해 행 삽입)
rectangle_input = [[0 for _ in range(m + 1)]]


for _ in range(n):
    # 라인별로 읽고 rectangle_input에 저장(편리한 인덱싱을 위해 [0] 삽입)
    line_input = [0] + list(map(int, list(input())))
    rectangle_input.append(line_input)


# 답은 최댓값을 출력해야 하므로, 0으로 시작
ans = 0

# 합을 저장할 리스트
s = [[0 for _ in range(m+1)] for _ in range(n+1)]

# 리스트 s는 입력받은 직사각형의 1,1부터 영역 내 모든 수의 합을 저장
for row in range(1, n + 1):
    for col in range(1, m + 1):
        s[row][col] = s[row - 1][col] + s[row][col - 1] - s[row - 1][col - 1] + rectangle_input[row][col]


def sum_cal(x1, y1, x2, y2):
    return s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]


# 첫 번째 경우: 전체 직사각형을 세로로만 분할한 경우
for i in range(1, m-1):
    for j in range(i+1, m):
        r1 = sum_cal(1, 1, n, i)
        r2 = sum_cal(1, i+1, n, j)
        r3 = sum_cal(1, j+1, n, m)
        if ans < r1 * r2 * r3:
            ans = r1 * r2 * r3


# 두 번째 경우: 전체 직사각형을 가로로만 분할한 경우
for i in range(1, n-1):
    for j in range(i+1, n):
        r1 = sum_cal(1, 1, i, m)
        r2 = sum_cal(i+1, 1, j, m)
        r3 = sum_cal(j+1, 1, n, m)
        if ans < r1 * r2 * r3:
            ans = r1 * r2 * r3

# 세 번째 경우: 전체 세로 분할 후 우측 가로 분할한 경우
for i in range(1, m):
    for j in range(1, n):
        r1 = sum_cal(1, 1, n, i)
        r2 = sum_cal(1, i+1, j, m)
        r3 = sum_cal(j+1, i+1, n, m)
        if ans < r1 * r2 * r3:
            ans = r1 * r2 * r3

# 네 번째 경우: 전체 세로 분할 후 좌측 가로 분할한 경우
for i in range(1, n):
    for j in range(1, m):
        r1 = sum_cal(1, 1, i, j)
        r2 = sum_cal(i+1, 1, n, j)
        r3 = sum_cal(1, j+1, n, m)
        if ans < r1 * r2 * r3:
            ans = r1 * r2 * r3

# 다섯번 째 경우: 전체 가로 분할 후 하단 세로 분할한 경우
for i in range(1, n):
    for j in range(1, m):
        r1 = sum_cal(1, 1, i, m)
        r2 = sum_cal(i+1, 1, n, j)
        r3 = sum_cal(i+1, j+1, n, m)
        if ans < r1 * r2 * r3:
            ans = r1 * r2 * r3

# 여섯번 째 경우: 전체 가로 분할 후 상단 세로 분할한 경우
for i in range(1, n):
    for j in range(1, m):
        r1 = sum_cal(1, 1, i, j)
        r2 = sum_cal(1, j+1, i, m)
        r3 = sum_cal(i+1, 1, n, m)
        if ans < r1 * r2 * r3:
            ans = r1 * r2 * r3

print(ans)
```

[참고](https://sdesigner.tistory.com/m/52)

- 직사각형을 3개의 작은 직사각형을 나누는 방법은 총 6가지이며, 각 경우의 수를 모두 탐색해 합의 곱을 비교하고 그 중 최댓값을 출력한다.

  - ㄱ, ㄴ, ㄷ를 나누는 선은 i와 j를 사용해 반복적으로 범위가 바뀌도록 지정한다

  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbuVo9L%2FbtqSXjNV05H%2FnZ7CkiZhMdQXH66jRDMdtk%2Fimg.png)

  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FttkEK%2FbtqSTI8yabk%2FCHlk16LT8lVoolt2kIhW10%2Fimg.png" style="zoom:30%;" />



### #10819 차이를 최대로

```python
# 내장함수(순열) 활용
from itertools import permutations


def solution(n, arr):
    answer = 0
    for x in permutations(arr, n):
        total = 0
        for i in range(n-1):
            total += abs(x[i]-x[i+1])
        if total > answer:
            answer = total
    return answer


if __name__ == "__main__":
    n = int(input())
    print(solution(n, list(map(int, input().split()))))
```

```python
# DFS로도 해결할 수 있다(백트래킹)
def dfs(depth):
    if depth == n:
        result.append(sum(abs(arr[i]-arr[i+1]) for i in range(n-1)))
    else:
        for i in range(n):
            if check[i]:
                continue
            arr.append(nums[i])
            check[i] = 1
            dfs(depth+1)
            arr.pop()
            check[i] = 0


if __name__ == "__main__":
    n = int(input())
    nums = list(map(int, input().split()))
    arr, result = [], []
    check = [0]*n
    dfs(0)
    print(max(result))
```

[참고](https://jinho-study.tistory.com/1035)

- 백트래킹을 할 때는 `check`의 해당 인덱스 원소를 0으로 초기화하고 `arr`의 마지막 원소 제거



### #10971 외판원 문제 2

```python
import sys


def dfs(start, next, value, visited):
    global min_value

    if len(visited) == N:
        if travel[next][start] != 0:
            min_value = min(min_value, value + travel[next][start])
        return

    for i in range(N):
        if travel[next][i] != 0 and i != start and i not in visited:
            visited.append(i)
            dfs(start, i, value + travel[next][i], visited)
            visited.pop()


if __name__ == "__main__":

    N = int(input())
    travel = [list(map(int, input().split())) for _ in range(N)]

    min_value = sys.maxsize

    for i in range(N):
        dfs(i, i, 0, [i])

    print(min_value)
```

[참고](https://jjangsungwon.tistory.com/4)

- PyPy3로 채점해야 시간 초과가 나지 않는다..
- 원리
  - 각 번호에서 출발하여 제자리로 돌아오는 값을 구한다.
  - 1번 과정을 반복하면서 최솟값을 업데이트한다.



### #1697 숨바꼭질

```python
from collections import deque


def solution(n, k):
    dist = [0]*(10**5+1)
    queue = deque()
    queue.append(n)
    while queue:
        temp = queue.popleft()
        if temp == k:
            return dist[temp]
        for x in (temp-1, temp+1, temp*2):
            if 0 <= x <= 10**5 and not dist[x]:
                dist[x] = dist[temp] + 1
                queue.append(x)


if __name__ == "__main__":
    n, k = map(int, input().split())
    print(solution(n, k))
```

[참고](https://wook-2124.tistory.com/273)

- 시간 초과가 발생하지 않도록 10**5로 제한
- dist 리스트를 이용하여 각각 이동해야 하는 거리를 구한다
